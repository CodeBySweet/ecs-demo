name: ECS Cluster and Application Deployment

on:
  workflow_dispatch:
    inputs:
      action:
        description: "Choose 'apply' to create resources or 'destroy' to tear them down."
        required: true
        default: "apply"
        type: choice
        options:
          - apply
          - destroy

env:
  AWS_REGION: us-east-1  # AWS region for deployment
  ECR_REPOSITORY: my-app-repo # Must match your Terraform ECR repository name

permissions:
  id-token: write   # Required for OIDC authentication
  contents: read    # Required for actions/checkout

jobs:
  deploy-or-destroy:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the code
      - name: Checkout code
        uses: actions/checkout@v3

      # Step 2: Configure AWS credentials via OIDC
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::626635421987:role/GitHubOIDCRole
          aws-region: ${{ env.AWS_REGION }}

      # Step 3: Set up Terraform
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7
          terraform_wrapper: false

      # Step 4: Initialize Terraform
      - name: Terraform Init
        run: terraform init

      # Step 5: Terraform Plan (for apply actions)
      - name: Terraform Plan
        if: github.event.inputs.action == 'apply'
        run: terraform plan

      # Step 6: Apply or Destroy Terraform configuration
      - name: Terraform Apply or Destroy
        run: |
          if [ "${{ github.event.inputs.action }}" == "apply" ]; then
            echo "Applying Terraform configuration..."
            terraform apply -auto-approve
          elif [ "${{ github.event.inputs.action }}" == "destroy" ]; then
            echo "Destroying Terraform configuration..."
            terraform destroy -auto-approve
          else
            echo "❌ Invalid action specified. Use 'apply' or 'destroy'."
            exit 1
          fi

      # Step 7: Skip Docker steps if action is 'destroy'
      - name: Check if action is 'apply'
        id: check-action
        run: |
          if [ "${{ github.event.inputs.action }}" == "apply" ]; then
            echo "should_run=true" >> $GITHUB_OUTPUT
          else
            echo "should_run=false" >> $GITHUB_OUTPUT
          fi

      # Step 8: Get Terraform outputs (only if action is 'apply')
      - name: Get Terraform Outputs
        if: steps.check-action.outputs.should_run == 'true'
        id: terraform-outputs
        run: |
          echo "ECR_REPOSITORY_URL=$(terraform output -raw ecr_repository_url)" >> $GITHUB_ENV
          echo "ECS_CLUSTER_NAME=$(terraform output -raw ecs_cluster_name)" >> $GITHUB_ENV
          echo "ECS_SERVICE_NAME=$(terraform output -raw ecs_service_name)" >> $GITHUB_ENV

      # Step 9: Install dependencies (only if action is 'apply')
      - name: Install dependencies
        if: steps.check-action.outputs.should_run == 'true'
        run: |
          echo "Installing dependencies..."
          pip install -r requirements.txt

      # Step 10: Install Docker and ECR Credential Helper
      - name: Install Docker and ECR Credential Helper
        if: steps.check-action.outputs.should_run == 'true'
        run: |
          echo "Installing Docker..."
          sudo apt-get remove -y docker docker-engine docker.io containerd runc || true
          sudo apt-get update
          sudo apt-get install -y \
              apt-transport-https \
              ca-certificates \
              curl \
              gnupg-agent \
              software-properties-common
          curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
          sudo add-apt-repository \
             "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
             $(lsb_release -cs) \
             stable"
          sudo apt-get update
          sudo apt-get install -y docker-ce docker-ce-cli containerd.io
          sudo usermod -aG docker $USER
          sudo apt-get install -y amazon-ecr-credential-helper
          mkdir -p ~/.docker
          echo '{"credsStore":"ecr-login"}' > ~/.docker/config.json

      # Step 11: Set up Docker Buildx
      - name: Set up Docker Buildx
        if: steps.check-action.outputs.should_run == 'true'
        uses: docker/setup-buildx-action@v2

      # Step 12: Get commit hash and timestamp for tagging
      - name: Get image tags
        if: steps.check-action.outputs.should_run == 'true'
        id: get-tags
        run: |
          echo "commit_hash=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "timestamp=$(date +'%Y%m%d%H%M')" >> $GITHUB_OUTPUT

      # Step 13: Login to Amazon ECR
      - name: Login to Amazon ECR
        if: steps.check-action.outputs.should_run == 'true'
        uses: aws-actions/amazon-ecr-login@v2
        id: login-ecr

      # Step 14: Build, tag, and push Docker image with multiple tags
      - name: Build, tag, and push Docker image to Amazon ECR
        if: steps.check-action.outputs.should_run == 'true'
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          # Build with multiple tags
          docker buildx build \
            --platform linux/amd64 \
            --push \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:${{ steps.get-tags.outputs.commit_hash }} \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:${{ steps.get-tags.outputs.timestamp }} \
            -f app/Dockerfile .
          
          # Set the primary image tag as output
          echo "IMAGE_TAG=${{ steps.get-tags.outputs.commit_hash }}" >> $GITHUB_ENV

      # Step 15: Check ECR image scan findings
      - name: Check ECR image scan findings
        if: steps.check-action.outputs.should_run == 'true'
        run: |
          echo "Waiting for scan completion..."
          aws ecr wait image-scan-complete \
            --repository-name $ECR_REPOSITORY \
            --image-id imageTag=latest

          echo "Checking scan findings..."
          FINDING_SEVERITIES=$(aws ecr describe-image-scan-findings \
            --repository-name $ECR_REPOSITORY \
            --image-id imageTag=latest \
            --query 'imageScanFindings.findingSeverityCounts' \
            --output json)

          echo "Findings: $FINDING_SEVERITIES"
          
          CRITICAL_COUNT=$(echo $FINDING_SEVERITIES | jq -r '.CRITICAL // 0')
          if [ $CRITICAL_COUNT -gt 0 ]; then
            echo "❌ Critical vulnerabilities found"
            exit 1
          fi

      # Step 16: Force new ECS deployment with the new image
      - name: Force new ECS deployment
        if: steps.check-action.outputs.should_run == 'true'
        run: |
          echo "Updating ECS Service..."
          aws ecs update-service \
            --cluster $ECS_CLUSTER_NAME \
            --service $ECS_SERVICE_NAME \
            --force-new-deployment \
            --region $AWS_REGION
          echo "✅ ECS Service updated successfully."